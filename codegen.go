package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"runtime/debug"
)

var i = 0

func generateCode(pkgName string, directives []directive) error {
	repo := ""
	if info, ok := debug.ReadBuildInfo(); ok {
		repo = info.Path
	}

	b := bytes.NewBuffer(nil)
	fmt.Fprintf(b, "// Code generated by https://%v; DO NOT EDIT.\n\n", repo)

	fmt.Fprintln(b, "package", pkgName)

	fmt.Fprintln(b, "import (")
	fmt.Fprintf(b, `"%v/encryptedfs"`+"\n", repo)
	if tool, err := os.ReadFile("tool"); err == nil {
		fmt.Fprintf(b, `"%s"`+"\n", string(tool))
	}
	if needsEmbed(directives) {
		fmt.Fprintln(b, `"embed"`)
	} else {
		fmt.Fprintln(b, `_ "embed"`)
	}
	b.WriteString(")\n")

	b.WriteString("var key []byte\n")
	b.WriteString("func init(){\n")
	b.WriteString(" key=tool.Priv()\n")
	b.WriteString("}\n")

	for _, d := range directives {
		initCode(b, d)
	}

	formatted, err := format.Source(b.Bytes())
	if err != nil {
		return err
	}

	return os.WriteFile("encrypted_fs.go", formatted, 0666)
}

func needsEmbed(directives []directive) bool {
	for _, d := range directives {
		if d.typ == "embed.FS" {
			return true
		}
	}

	return false
}

func initCode(b *bytes.Buffer, d directive) {
	i++
	fmt.Fprintf(b, "//go:embed %v\n", filesString(d.files))
	fmt.Fprintf(b, "var enc%d %v\n", i, d.typ)

	b.WriteString("func init(){\n")
	switch d.typ {
	case "string":
		fmt.Fprintf(b, "%v = encryptedfs.DecString(enc%d, key)", d.identifier, i)
	case "[]byte":
		fmt.Fprintf(b, "%v = encryptedfs.DecByte(enc%d, key)", d.identifier, i)
	case "embed.FS":
		fmt.Fprintf(b, "%v = encryptedfs.InitFS(enc%d, key)", d.identifier, i)
	}

	b.WriteString("}\n")
}

func filesString(files []string) string {
	out := ""
	for _, file := range files {
		out += fmt.Sprintf("%q ", file+".enc")
	}

	return out
}
